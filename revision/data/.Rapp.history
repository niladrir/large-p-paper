n <- 20#
pos <- sample(n, 1)#
#
lineup.dat <- lineup(null_permute("X2"), true = X)
decrypt("pyT9 8BGB VF oI1VGVIF n")
distmet <- function(dat, pos, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
  }
distmet(lineup.dat, pos = 7, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup(null_permute("X2"), true = X), pos = 7, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup(null_permute("X2"), true = X, pos = 7), pos = 7, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
lineup.dat <- lineup(null_permute("X2"), true = X)#
#
qplot(X1, X2, data = lineup.dat ) + facet_wrap(~ .sample)#
#
distmet(lineup.dat, pos = 7, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, pos = 12, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
lineup.dat <- lineup(null_permute("X2"), true = X)
distmet <- function(dat, pos = NULL, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(is.null(pos)){#
		stop("Need the position of the true dataset")#
	}#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
  }
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
?stop
iter <- 12#
if(iter > 10) stop("too many iterations")
distmet <- function(dat, pos = NULL, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(is.null(pos)){#
		message("Need the position of the true dataset")#
	}#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
  }
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet <- function(dat, pos = NULL, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(is.null(pos)){#
		stop("Need the position of the true dataset")#
	}else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
pos = NULL
is.null(pos)
distmet <- function(dat, pos = NULL, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(is.null(pos)){#
		stop("Need the position of the true dataset")#
	}else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, null_permute("X2"), pos = 7, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet <- function(dat, pos = NULL, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(!is.null(pos)){#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
   else{#
   stop("Need the position of the true dataset")#
	}#
  }
distmet(lineup.dat, null_permute("X2"), pos = 7, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
pos = NULL
!is.null(pos)
distmet <- function(dat, pos = 0, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(pos != 0){#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
   else{#
   stop("Need the position of the true dataset")#
	}#
  }
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 7, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 0, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
?missing
distmet <- function(dat, pos, method, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(pos)){#
		 stop("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  	#	all <- all_sample(true.dat, repl, no.samp, null_permute("tip"))#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		# 	cal.mean <- mean.samp(dat, no.samp, null_permute("X1"))#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, null_permute("X2"), meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
?missing
myplot <- function(x,y) {#
                if(missing(y)) {#
                        y <- x#
                        x <- 1:length(y)#
                }#
                plot(x,y)#
        }
myplot(rnorm(10))
?stop
tst1 <- function(...) stop("dummy error")#
tst1(1:10, long, calling, expression)
?message
message("ABC", "DEF")
?break
distmet <- function(dat, method, pos, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(pos)){#
		 cat("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, null_permute("X2"),  meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
?elseif
distmet(lineup.dat, null_permute("X2"), pos = 2)
distmet(lineup.dat, null_permute("X2"), pos = 2, repl = 10000)
distmet(lineup.dat, pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("y"), pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet <- function(dat, method, pos, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(method)){#
		cat("Need the null generating mechanism")#
	}#
	if(missing(pos)){#
		 cat("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet <- function(dat, method, pos, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(method)){#
		cat("Need the null generating mechanism")#
		break()#
	}#
	if(missing(pos)){#
		 cat("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
  }
distmet(lineup.dat, pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet <- function(dat, method, pos, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(method)){#
		cat("Need the null generating mechanism")#
	}else{#
	if(missing(pos)){#
		 cat("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  		 if(plot){#
  		 	cal.mean <- mean.samp(dat, no.samp, method)#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
   }#
  }
distmet(lineup.dat, pos = 2, meas.distr = TRUE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = TRUE, plot = FALSE, repl = 1000, no.samp = 20)
distmet <- function(dat, method, pos, meas.distr = FALSE, plot = FALSE, repl = 100, no.samp = 10 ){#
	if(missing(method)){#
		cat("Need the null generating mechanism")#
	}else{#
	if(missing(pos)){#
		 cat("Need the position of the true dataset")#
		 }else{#
	true.dat <- data.frame(dat[,1][dat$.sample == pos], dat[,2][dat$.sample == pos])#
	names(true.dat) <- names(dat[,1:2])#
	WBdist <- NULL#
  	 for(i in 1:length(unique(dat$.sample))){ #
  	 	wb_dist = wbdist_fun(dens_z(true.dat), dens_z(data.frame(dat[,1][dat$.sample == i], dat[,2][dat$.sample == i])))#
  	 	WBdist<-rbind(WBdist, data.frame(PlotNo = i, wb_dist))#
  	 	}#
  	 plots <- WBdist[order(WBdist$wb_dist), ]$PlotNo[2:6]#
  	   	if(meas.distr){#
  		all <- all_sample(true.dat, repl, no.samp, method)#
  		    cal.mean <- mean.samp(dat, no.samp, method)#
  		 	perc.val <- sum(all > cal.mean$means[cal.mean$PlotNo == pos])/repl#
  		 	ratio <- perc.val*repl/sum(all > max(cal.mean$means[cal.mean$PlotNo != pos])) #
  		 if(plot){#
  		 	dev.new()#
  		 	p <- qplot(all, geom="density", fill=I("grey80"), colour=I("grey80"), xlab="Permutation distribution", ylab="") + geom_segment(aes(x=cal.mean$means[cal.mean$PlotNo != pos], xend = cal.mean$means[cal.mean$PlotNo != pos], y=rep(- 0.02, 19), yend=rep(-0.05*max(density(all)$y), 19)), size=1, alpha = I(0.7)) + geom_segment(aes(x= cal.mean$means[cal.mean$PlotNo == pos], xend = cal.mean$means[cal.mean$PlotNo == pos], y=- 0.02, yend = -0.1*max(density(all)$y)), colour="darkorange", size=1)#
  		 	return(list(all.wb = all, wbdist = WBdist, closest = plots, perc.val = perc.val, ratio = ratio,cal.mean = cal.mean, p))#
  		 }#
  		 else#
  		 return(list(all.wb = all, wbdist = WBdist, closest = plots, cal.mean = cal.mean))#
  	}#
  	else#
  return(list( wbdist = WBdist, closest = plots)) #
   }#
   }#
  }
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = TRUE, plot = FALSE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = FALSE, plot = FALSE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = FALSE, plot = TRUE, repl = 1000, no.samp = 20)
distmet(lineup.dat, null_permute("X2"), pos = 2, meas.distr = TRUE, plot = TRUE)
distmet(lineup.dat)
distmet(lineup.dat, null_permute("X2") )
distmet(lineup.dat, null_permute("X2"), pos = 4 )
distmet(lineup.dat, null_permute("X2"), pos = 4, plot = T )
distmet(lineup.dat, null_permute("X2"), pos = 4, plot = T, meas.distr = T )
.old <- c(LETTERS, letters, 0:9)#
.new <- sample(.old)#
#
.old_string <- paste(.old, collapse = "")#
.new_string <- paste(.new, collapse = "")#
#
encrypt <- function(...) {#
  message <- paste(..., sep = "")#
  chartr(.old_string, .new_string, message)#
}#
#
#' Use decrypt to reveal the position of the real data. #
#'#
#' The real data position is encrypted by the lineup function, and#
#' writes this out as a text string. Decrypt, decrypts this text#
#' string to reveal which where the real data is.#
#'#
#' @param ... character vector to decrypt#
#' @export#
#' @examples#
#' decrypt("0uXR2p rut L2O2")#
decrypt <- function(...) {#
  message <- paste(..., sep = "")#
  chartr(.new_string, .old_string, message)#
}#
###=====================================================================#
#
dists <- c(beta = "beta", cauchy = "cauchy", "chi-squared" = "chisq", #
  exponential = "exp", f = "f", gamma = "gamma", geometric = "geom",#
  "log-normal" = "lnorm", "lognormal" = "lnorm", logistic = "logis", #
  "negative binomial" = "nbinom", normal = "norm", poisson = "pois", #
  t = "t", weibull = "weibull")#
#
# Specific distribution ------------------------------------------------------#
#
#' Generate null data with a specific distribution.#
#'#
#' Null hypothesis: variable has specified distribution#
#' #
#' @param var variable name#
#' @param dist distribution name. One of: beta, cauchy, chi-squared,#
#'   exponential, f, gamma, geometric, log-normal, lognormal, logistic,#
#'   negative binomial, normal, poisson, t, weibull#
#' @param params list of parameters of distribution. If \code{NULL}, will#
#'   use \code{\link[MASS]{fitdistr}} to estimate them.#
#' @return a function that given \code{data} generates a null data set.  #
#'   For use with \code{\link{lineup}} or \code{\link{rorschach}}#
#' @export#
null_dist <- function(var, dist, params = NULL) {#
  dist <- match.arg(dist, names(dists))#
  generator <- match.fun(paste("r", dists[dist], sep = ""))#
  function(df) {#
    # If parameters not specified, use fitdistr from MASS to find them#
    if (is.null(params)) {#
      params <- as.list(coef(MASS::fitdistr(df[[var]], dist)))#
    }#
    params$n <- nrow(df)#
    df[[var]] <- do.call(generator, params)#
    df#
  }#
}#
# Multivariate independence --------------------------------------------------#
#' Generate null data by permuting a variable.#
#'#
#' Null hypothesis: variable is independent of others#
#' #
#' @param var name of variable to permute#
#' @return a function that given \code{data} generates a null data set.  #
#'   For use with \code{\link{lineup}} or \code{\link{rorschach}}#
#' @export#
null_permute <- function(var) {#
  function(df) {#
    df[[var]] <- sample(df[[var]])#
    df#
  }#
}
null_lm <- function(f, method = "rotate", ...) {#
  if (is.character(method)) {#
    method <- match.fun(paste("resid", method, sep = "_"))#
  }#
  function(df) {#
    model <- eval(substitute(lm(formula, data = df), list(formula = f)))#
    resp_var <- all.vars(f[[2]])#
    resid <- method(model, df, ...)#
    fitted <- predict(model, df)#
    df[".resid"] <- resid#
    df[".fitted"] <- fitted#
    df[[resp_var]] <- fitted + resid#
    df#
  }#
}#
#
# Extractor methods#
rss <- function(model) sum(resid(model) ^ 2)#
sigma <- function(model) summary(model)$sigma#
n <- function(model) length(resid(model))#
#
#' Rotation residuals.#
#'#
#' For use with \code{\link{null_lm}}#
#'#
#' @param model to extract residuals from#
#' @param data used to fit model#
#' @export#
resid_rotate <- function(model, data) {#
  data[names(model$model)[1]] <- rnorm(nrow(data))#
#
  rmodel <- update(model, data = data)#
  resid(rmodel) * sqrt(rss(model) / rss(rmodel))#
}#
#
#' Parametric bootstrap residuals.#
#'#
#' For use with \code{\link{null_lm}}#
#'#
#' @param model to extract residuals from#
#' @param data used to fit model#
#' @export#
resid_pboot <- function(model, data) {#
  rnorm(n = n(model), sd = sqrt(sigma(model)))  #
}#
#
#' Residuals simulated by a normal model, with specified sigma#
#'#
#' For use with \code{\link{null_lm}}#
#'#
#' @param model to extract residuals from#
#' @param data used to fit model#
#' @param sigma, a specific sigma to model#
#' @export#
resid_sigma <- function(model, data, sigma=1) {#
  rnorm(n = n(model), sd = sigma)  #
}#
#
#' Bootstrap residuals.#
#'#
#' For use with \code{\link{null_lm}}#
#'#
#' @param model to extract residuals from#
#' @param data used to fit model#
#' @export#
resid_boot <- function(model, data) {#
  sample(resid(model))#
}#
#
###========================================#
###Distance Measure#
###========================================#
# distance between densities#
wbdist_fun = function(z1, z2) {#
	sqrt(sum((z1 - z2)^2)/(sum(z1^2) * sum(z2^2)))#
}#
# get densities#
dens_z = function(dat, nbins = 10) {#
res = MASS::kde2d(dat[, 1], dat[, 2], n = nbins, lims = c(range(dat[, 1]), range(dat[, 2])))#
res$z#
}#
#
###=========================================#
### Mean Wbdist of null data (size  = no.samp)#
###=========================================#
#
mean_met <- function(dat, no.samp, method){#
	z1 = dens_z(dat)#
	dat1 <- data.frame(1:no.samp, true_wbdist = replicate(no.samp, {#
		r = method(dat)#
	#	r = cbind(dat[,1], null_permute("X1")(dat))#
		z2 = dens_z(r)#
	  wbdist_fun(z1, z2)#
	}))#
  mean(dat1[,2])#
}
all_sample = function(dat, repl, no.samp, method) {#
	mean.WBdist_all <- NULL	#
	for(i in 1:repl){#
		samp.dat <- method(dat)#
		z3 <- dens_z(samp.dat)#
#z1 = dens_z(data)  # this does not change; only needs to be computed once#
dat2 <- data.frame(k = 1:no.samp, null_wbdist = replicate(no.samp, {#
	r = method(samp.dat)#
	z4 = dens_z(r)#
	wbdist_fun(z3, z4)#
}))#
	mean.WBdist_all <- c(mean.WBdist_all,  mean(dat2[,2]) )#
}#
return(mean.WBdist_all)#
}#
#
#all_sample(X, 50, 10, null_permute("X1"))#
#
#all_sample(X, 50, 10, null_dist("X1", "cauchy"))#
#
###===================================#
### Function to calculate the mean#
###===================================#
#
mean.samp <- function(dat, no.samp, method){#
	dat1 <- NULL#
for (i in 1:length(unique(dat$.sample))){#
	dat1 <- rbind(dat1, data.frame(PlotNo = i, means = mean_met(dat[dat$.sample == i,], no.samp, method)))#
}#
return(dat1)#
}#
#
#mean.samp(lineup.dat, 10, null_permute("X1"))#
###=========================================#
###Protocols#
###=========================================#
#' The Rorschach protocol.#
#'#
#' This protocol is used to calibrate the eyes for variation due to sampling.#
#' All plots are typically null data sets, data that is consistent with a null#
#' hypothesis. The protocol is described in Buja, Cook, Hofmann, Lawrence,#
#' Lee, Swayne, Wickham (2009) Statistical inference for exploratory data#
#' analysis and model diagnostics, Phil. Trans. R. Soc. A, 367, 4361-4383.#
#'#
#' @export#
#' @importFrom plyr rdply#
#' @param method method for generating null data sets#
#' @param true true data set. If \code{NULL}, \code{\link{find_plot_data}}#
#'   will attempt to extract it from the current ggplot2 plot.#
#' @param n total number of samples to generate (including true data)#
#' @param p probability of including true data with null data.#
rorschach <- function(method, true = NULL, n = 20, p = 0) {#
  true <- find_plot_data(true)#
  show_true <- rbinom(1, 1, p) == 1#
  if (show_true) {#
    n <- n - 1#
  }#
#
  samples <- rdply(n, method(true))#
  if (show_true) {#
    pos <- sample(n + 1, 1)#
    message(encrypt("True data in position ", pos))#
    samples <- add_true(samples, true, pos)#
  }#
  samples#
}
add_true <- function(samples, true, pos) {#
  samples$.sample <- with(samples, ifelse(.n >= pos, .n + 1, .n))#
  samples$.n <- NULL#
  true$.sample <- pos#
  all <- rbind.fill(samples, true)#
  all[order(all$.sample), ]#
}#
#
#' Find plot data.#
#' If data is not specified, this function will attempt to find the data#
#' corresponding to the last ggplot2 created or displayed. This will work#
#' in most situations where you are creating the plot and immediately #
#' displaying it, but may not work in other situations.  In those cases,#
#' please specify the data explicitly.#
#'#
#' @keywords internal#
#' @importFrom ggplot2 last_plot#
find_plot_data <- function(data) {#
  if (!is.null(data)) return(data)#
#
  if (exists("last_plot") && !is.null(last_plot())) {#
    last_plot()$data#
  } else {#
    stop("Missing true dataset")#
  }#
}#
#
##find_plot_data(A)#
###================================================#
###Calculating weighted bin distance of the lineup data#
###================================================#
lineup <- function(method, true = NULL, n = 20, pos = sample(n, 1) , samples = NULL) {#
 true <- find_plot_data(true)#
  if (is.null(samples)) {#
    samples <- rdply(n - 1, method(true))#
  }#
  if (missing(pos)) {#
    message("decrypt(\"", encrypt("True data in position ", pos), "\")")#
  }#
  add_true(samples, true, pos)#
 }
x <- rnorm(30)#
y <- 0.99*x + rnorm(30)#
cor(x,y)#
corr <- cor(x,y)#
X <- data.frame(X1 = x, X2 = y)#
t <- corr*sqrt(length(x) - 2)/sqrt(1 - corr^2)#
2*(1 - pt(abs(t), length(x) - 2))#
#all.dat  <-  all_sample(X)#
#
library(plyr)#
library(ggplot2)#
samples <- ldply(1:19, function(k){#
	data.frame(X1 = X$X1, X2 = X$X2[sample(dim(X)[1])], .n = k )#
})
lineup.dat <- lineup(null_permute("X2"), true = X)
qplot(X1, X2, data = lineup.dat ) + facet_wrap(~ .sample)
time <- c(0, 20, 40, 60, 80, 100)#
surv <- c(1, 0.998, 0.912, 0.856, 0.712, 0.534)#
#
dat <- data.frame(time, surv)
dat
t <- sample(1:100, 10)
t
t.ord <- order(t)
t.ord
t.ord <- sort(t)
t.ord
t.sort <- sort(t)
diff(dat$time)
surviv <- NULL#
for (i in 1:length(t.sort)){#
	surviv[i] <- dat$surv[t.sort[i]<max(dat$time[dat$time<t.sort[i]])]#
}
surviv
dat$time[dat$time<t.sort[1]]
dat$time[dat$time<t.sort[2]]
dat$time[dat$time<t.sort[3]]
dat$time[dat$time<t.sort[4]]
max(dat$time[dat$time<t.sort[i]])
t.sort[4]<max(dat$time[dat$time<t.sort[4]])
max(dat$time[dat$time<t.sort[4]])
dat$surv[dat$time == max(dat$time[dat$time<t.sort[i]])]
dat$surv[dat$time == max(dat$time[dat$time<t.sort[4]])]
dat$surv[dat$time == max(dat$time[dat$time<t.sort[5]])]
surviv <- NULL#
for (i in 1:length(t.sort)){#
	surviv[i] <- dat$surv[dat$time == max(dat$time[dat$time<t.sort[i]])]#
}
surviv
?ldply
library(plyr)
?ldply
is.list(t.sort)
t.sort <- data.frame(sort(t))
t.sort
t.sort <- data.frame(t.so = sort(t))
t.sort
t <- sample(1:100, 10)#
#
t.sort <- data.frame(t.so = sort(t), ord = order(t))
t.sort
t.sort <- data.frame(t.so = sort(t), ord = 1:length(t))
t.sort
ddply(t.sort, .(ord), summarise, surviv = dat$surv[dat$time == max(dat$time[dat$time<t.so[ord]])])
ddply(t.sort, .(t.so), summarise, surviv = dat$surv[dat$time == max(dat$time[dat$time<t.so])])
dat
mu <- 69#
sigma <- 2.8#
c(mu-2*sigma, mu + 2*sigma)#
mu - sigma#
mu + 3*sigma#
#
(71 - 69)/2.8#
#
(60 - 69)/2.8
round((71 - 69)/2.8,2)#
#
round((60 - 69)/2.8,2)
18.5*3
120-55.5
120+55.5
120+54
120-54
time <- c("Last Year", "Last Week", "Current")#
prices <- c(3.17, 3.51, 3.57)#
#
library(ggplot2) #
#
qplot(time, prices, geom = "line")
qplot(time, prices, geom = c("point","line"))
time <- c(1,2,3)#
prices <- c(3.17, 3.51, 3.57)#
#
library(ggplot2) #
#
qplot(time, prices, geom = c("point","line"))
qplot(time, prices, geom = c("point","line")) +scale_x_discrete(labels = c("Last Year", "Last Week", "Current"))
x <- sample(rpois(5, 2))
x
x <- sample(rpois(5, 15))
x
x <- sample(rpois(5, 15))#
catg <- c("Red", "Blue", "Yellow", "Green", "Black")#
#
qplot(catg, weights = x)
qplot(catg, weight = x)
time <- c(1,2,3)#
prices <- c(3.17, 3.51, 3.57)#
#
library(ggplot2) #
#
qplot(time, prices, geom = c("point","line")) +scale_x_discrete(labels = c("Last Year", "Last Week", "Current"))
x <- rnorm(30, 10, 1)#
y <- rpois(30, 4)
library(ggplot2)#
qplot(x, y, size = I(3))
qplot(x, y, size = I(3)) + geom_line(method = "lm")
qplot(x, y, size = I(3)) + geom_smooth(method = "lm")
qplot(x, y, size = I(3)) + geom_smooth(method = "lm", se = FALSE)
mod <- lm(y ~ x)
qplot(x, mod$resid)
qqnorm(mod$resid)
qqplot(mod$resid)
x <- rnorm(30, 10, 1)#
y <- rgamma(30, 4, 2)#
#
library(ggplot2)#
qplot(x, y, size = I(3)) + geom_smooth(method = "lm", se = FALSE)#
#
mod <- lm(y ~ x)#
#
qplot(x, mod$resid)
qqnorm(mod$resid)
sample(1:100, 12)
x <- rchisq(100,29)
boxplot(x)
qplot(x, geom = "boxplot", size = 1.2)
library(ggplot2)#
qplot(x, geom = "boxplot", size = 1.2)
qplot(x, y,  geom = "boxplot", size = 1.2)
x <- rchisq(100,29)#
#
y < -1#
#
library(ggplot2)#
qplot(x, y,  geom = "boxplot", size = 1.2)
x <- rchisq(100,29)#
#
y <- 1#
#
library(ggplot2)#
qplot(x, y,  geom = "boxplot", size = 1.2)
x <- rchisq(100,29)#
#
y <- rep(1, 100)#
#
library(ggplot2)#
qplot(x, y,  geom = "boxplot", size = 1.2)
qplot( y, x,  geom = "boxplot", size = 1.2)
qplot( y, x,  geom = "boxplot")
x <- rchisq(100,7)#
#
y <- rep(1, 100)#
#
library(ggplot2)#
qplot( y, x,  geom = "boxplot")
boxplot(x)
?boxplot
boxplot(x, horizontal = T)
mean(427, 442)
mean(c(427, 442))
mean(c(396, 402))
mean(c(457, 488))
69 -2.8
69 -2*2.8
69 +2*2.8
69 +3*2.8
(71 -69)/2.8
(60 -69)/2.8
library(nullabor)
install.packages("nullabor")
library(nullabor)
?lineup
?apply
??lda
library(MASS)
?lda
x <- 1:31#
sample(x, 3)
library(plyr)#
x <- 1:31#
ldply(1:100, function(k){#
	dat <- sample(x, 3)#
	}
)
x <- 1:31#
randdat <- ldply(1:100, function(k){#
	dat <- sample(x, 3)#
	}
)
melt(randdat)
library(reshape)
melt(randdat)
rand.m <- melt(randdat)
library(ggplot2)
qplot(value, data = rand.m)
rand.mean <- apply(randdat, 1, mean)
rand.mean
qplot(rand.mean)
library(plyr)#
x <- 1:31#
randdat <- ldply(1:100, function(k){#
	dat <- sample(x, 6)#
	})#
library(reshape)	#
rand.m <- melt(randdat)#
library(ggplot2)#
qplot(value, data = rand.m)
rand.mean <- apply(randdat, 1, mean)#
#
qplot(rand.mean)
library(plyr)#
x <- 1:31#
randdat <- ldply(1:30, function(k){#
	dat <- sample(x, 6)#
	})#
library(reshape)	#
rand.m <- melt(randdat)#
library(ggplot2)#
qplot(value, data = rand.m)
rand.mean <- apply(randdat, 1, mean)#
#
qplot(rand.mean)
x <- sample(1:100, 10)
x
median(x)
median(x); mean(x); sd(x); iqr(x)
quantile(x, 0.75)
median(x); mean(x); sd(x); quantile(x, 0.75) - quantile(x, 0.25)
median(x); mean(x); sd(x); as.numeric(quantile(x, 0.75) - quantile(x, 0.25))
x[2] <- x[2] - 2
x[2]
x[5] <- x[5] + 2
x[5]
median(x); mean(x); sd(x); as.numeric(quantile(x, 0.75) - quantile(x, 0.25))
sort(x)
x <- sample(1:100, 10)#
#
median(x); mean(x); sd(x); as.numeric(quantile(x, 0.75) - quantile(x, 0.25))
sort(x)
x
x[2] <- x[2] - 2#
#
x[7] <- x[7] + 2#
#
median(x); mean(x); sd(x); as.numeric(quantile(x, 0.75) - quantile(x, 0.25))
(0.95 - 0.35)/0.6
100 -93
3.5
0.035
-1.81 * 0.6 + 0.35
1.81 * 0.6 + 0.35
-0.67 * 0.6 + 0.35
library(tourr)#
library(ggplot2)
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 2)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
library(MASS)#
#
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 2)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
library(MASS)#
#
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 5)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
library(MASS)#
#
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 10)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
library(MASS)#
#
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 15)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
generate_plot_lda<-function(n, p){#
#random <- read.csv("Dataset1.csv", header=T)#
	x<-matrix(rnorm(p*n),ncol=p)#
	colnames(x)<-paste("X",1:(p),sep="")#
   x<-scale(x)#
   cl=c(rep(1,n/2),rep(2,n/2))#
   d=1#
x.lda <- lda(x,cl)#
x.ld <- predict(x.lda,dimen=1)$x#
true<-data.frame(x.ld, cl)#
if(mean(true$LD1[1:n/2])>0)#
true$cl<-c(rep(2,n/2),rep(1,n/2))#
return(true)#
}#
#
true <- generate_plot_lda(n = 30, p = 25)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 27)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 29)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 100)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 30)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 28)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 29)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))  + scale_x_continuous("LD1", breaks=c(-1.5,0.0,1.5))
true <- generate_plot_lda(n = 30, p = 29)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
true <- generate_plot_lda(n = 30, p = 28)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
true <- generate_plot_lda(n = 30, p = 2)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
true <- generate_plot_lda(n = 30, p = 10)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
true <- generate_plot_lda(n = 30, p = 20)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
true <- generate_plot_lda(n = 30, p = 28)#
true <- data.frame(true, y = rep(1.5,30))#
#
qplot(LD1,y, data = true, colour=factor(cl),geom="jitter", size = I(3)) + scale_colour_discrete(name="Group") + scale_y_continuous("",breaks=c(0,1.5,3),limits=c(0,3))
p <- seq(0, 50, by = 1)#
n <- c(30, 50)#
#
prob <-  function(n){choose(n - 1, p)/(2^(n - 1))}#
#
dat.prob <- data.frame(dimension = p, Pr.30 = round(cumsum(prob(30)),4), Pr.50 = round(cumsum(prob(50)),4))
dat.prob
cumsum(prob(30))
dat <- read.csv("conc.csv")
head(dat)
dim(dat)
library(ggplot2)#
library(nullabor)
conc.data <- read.csv("conc.csv")#
#
qplot(label, conc, data=lineup(null_permute("label"), conc.data), colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample) + opts(legend.position="none")
qplot(label, conc, data=lineup(null_permute("label"), conc.data), pos = 16, colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample) + opts(legend.position="none")
qplot(label, conc, data=lineup(null_permute("label"), conc.data, pos = 16),  colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample) + opts(legend.position="none")
lineup.dat <- lineup(null_permute("label"), conc.data, pos = 16)
qplot(label, conc, data= lineup.dat,  colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample)
conc.data <- read.csv("conc.csv")#
#
lineup.dat <- lineup(null_permute("label"), conc.data, pos = 16)#
#
write.csv(lineup.dat, "lineup-conc.csv",row.names=F, quote=F)#
#
qplot(label, conc, data= lineup.dat,  colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample)#
#
ggsave("lineup-dot.pdf", width = 6.17, height = 5.17)
conc.data <- read.csv("conc.csv")#
#
lineup.dat <- lineup(null_permute("label"), conc.data, pos = 16)#
#
write.csv(lineup.dat, "lineup-conc.csv",row.names=F, quote=F)#
#
qplot(label, conc, data= lineup.dat,  colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample)#
#
ggsave("lineup-dot.pdf", width = 6.17, height = 5.17)
conc.data <- read.csv("conc.csv")#
#
lineup.dat <- lineup(null_permute("label"), conc.data, pos = 16)#
#
write.csv(lineup.dat, "lineup-conc.csv",row.names=F, quote=F)#
#
qplot(label, conc, data= lineup.dat,  colour=label, size=I(3), alpha=I(0.6), ylab="Conc (mg/kg)", xlab="Site") + facet_wrap(~.sample)#
#
ggsave("lineup-dot.pdf", width = 6.17, height = 5.17)
